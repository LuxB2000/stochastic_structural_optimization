#include "SolverTest.h"

CPPUNIT_TEST_SUITE_REGISTRATION(SolverTest);

SolverTest::SolverTest(){
	#ifdef _DATATESTPATH // from CMakeLists file
		m_data_path = _DATATESTPATH;
	#else
		// default path
		m_data_path = std::string("../tests/data");
	#endif
}

SolverTest::~SolverTest(){
}

void
SolverTest::setUp(){
}

void
SolverTest::tearDown(){
}

void
SolverTest::basic_tests(){
	TrussSolverType solver_t = TrussSolverType();
	BeamSolverType  solver_b = BeamSolverType();
}

void
SolverTest::horizontal_beam_test(void){
	/*
	 * Study case:
	 *
	 *            | 5kN
	 *            |
	 *           \/
	 * .---------.---------.
	 * /\        /\         
	 *
	 * |_________|_________|
	 *      2m        2m
	 *
	 * BarElementTest::truss_stiffness_tests
	 * Numerical solutions have been generated by the Matlab code presented in 
	 * "A 3D Finite Element modeling composite wind tubine wings" by R. DE FRIA LOPE.
	 */
	Point *p0 = PointManager::GetInstance().GetPoint(0.0,0.0,0.0),
	      *p1 = PointManager::GetInstance().GetPoint(2.0,0.0,0.0),
	      *p2 = PointManager::GetInstance().GetPoint(4.0,0.0,0.0);

	float cross_sec =  23E-4, // in m^2
				alpha = 0.0,
				f1y=-5E3;

	Material m = BASIC_C;

	int N = 3; // number of nodes/points
	arma::umat test;
	StiffnessMatrixType expected;

	// load the expected stiffness matrix
	bool check = expected.load(m_data_path + std::string("/Kg_Ctwo_horizontal_beams.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file Kg_Ctwo_horizontal_beams, may be you haven't run Matlab script",
			check,
			true
	);

	// create the element objects
	BeamBarElement b1 = BeamBarElement(p0, p1, cross_sec, m, alpha);
	BeamBarElement b2 = BeamBarElement(p1, p2, cross_sec, m, alpha);

	// create the stiffness matrix of the structure
	BeamStiffnessBuilder builder = BeamStiffnessBuilder(N);
	builder.Build(b1.GetStiffnessMatrix(), {0,1});
	builder.Build(b2.GetStiffnessMatrix(), {1,2});
	
	// test the stiffness matrix values
	test = arma::abs(expected-builder.GetStiffnessMatrix())<1E-6;
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We expect to find the same stiffness matrix as the file.",
			(int)(N*6*N*6),
			static_cast<int>(sum(sum(test,1)))
	);

	// Boundary conditions
	BoundaryConditionsVectorType bc = BoundaryConditionsVectorType();
	// all supports are fixed supports -> all reactions are constraint
	// all happens in a single plan -> only 1 DOF is free -> TRIVIAL CASE
	for( unsigned int i=0; i<N; i++ ){
		bc.push_back({i,0}); // Vx is constraint at pt 0
		if( i!=1) bc.push_back({i,1}); // Vy is constraint at pt 0
		bc.push_back({i,2}); // Vz is constraint at pt 0
		bc.push_back({i,3}); // Mx is constraint at pt 0
		bc.push_back({i,4}); // My is constraint at pt 0
		bc.push_back({i,5}); // Mz is constraint at pt 0
	}
	// external forces
	ForceVectorType f_ext = ForceVectorType(N*BeamType::NDOF); // size = #nodes*NDOF
	f_ext(7) = f1y;

	DisplacementVectorType expected_disp_gc, expected_disp_lc;
	check = expected_disp_gc.load(m_data_path + std::string("/disp_Ctwo_horizontal_beams.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file disp_Ctwo_horizontal_beams, may be you haven't run Matlab script",
			check,
			true
	);
	check = expected_disp_lc.load(m_data_path + std::string("/disp_lc_Ctwo_horizontal_beams.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file disp_Ctwo_horizontal_beams, may be you haven't run Matlab script",
			check,
			true
	);
	ForceVectorType f_reaction_sup_expected, f_elem_expected;
	check = f_reaction_sup_expected.load(m_data_path + std::string("/fsup_Ctwo_horizontal_beams.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file fsup_Ctwo_horizontal_beams, may be you haven't run Matlab script",
			check,
			true
	);
	check = f_elem_expected.load(m_data_path + std::string("/felem_Ctwo_horizontal_beams.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file felem_Ctwo_horizontal_beams, may be you haven't run Matlab script",
			check,
			true
	);

	// initialize the data
	DisplacementVectorType disp = DisplacementVectorType(N*BeamType::NDOF); // size = #nodes
	ForceVectorType f_reaction_sup = ForceVectorType(N*BeamType::NDOF); // size = #nodes*NDOF
	ForceVectorType f_elem = ForceVectorType((N-1)*2*BeamType::NDOF); // size = #element*2*NDOF, 2: two nodes per elements)

	// ================
	// Solve the system
	// ================
	BeamSolverType  solver = BeamSolverType(builder.GetStiffnessMatrix(),&bc,&f_ext,&disp,&f_reaction_sup,&f_elem);
	// 1- find displacements of the nodes.
	solver.ComputeNodeDisplacements();
	//solver.ComputeNodeDisplacements(&disp,builder.GetStiffnessMatrix(),&f_ext,&bc);
	arma::umat test_disp = arma::abs(disp-expected_disp_gc)<1E-6;
	//std::cout << disp << std::endl;
	//std::cout << expected_disp_gc << std::endl;
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We expect to find the same node displacement vector the file.",
			(int)(N*6),
			static_cast<int>(sum(sum(test_disp,1)))
	);

	// 2- find the support's reactions
	solver.ComputeSupportReactions();
	arma::umat test_sup=arma::abs(f_reaction_sup-f_reaction_sup_expected)<1E-6;
	//std::cout << f_reaction_sup_expected << std::endl;
	//std::cout << f_reaction_sup << std::endl;
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We expect to find the same support reactions vector as the file.",
			(int)(N*6),
			static_cast<int>(sum(sum(test_sup,1)))
	);

	// 3- find the elements' internal forces and displacement in local coordinates
	// Parse all the Element and set the displacements in global coordinates
	// Then, build the f_elem vector getting back the displacements in local coordinates
	// as well as the internal forces in local coordinates
	DisplacementVectorType disp1_gc = DisplacementVectorType(2*BeamType::NDOF),
												 disp2_gc = DisplacementVectorType(2*BeamType::NDOF),
												 disp1_lc = DisplacementVectorType(2*BeamType::NDOF),
												 disp2_lc = DisplacementVectorType(2*BeamType::NDOF),
													disp_lc = DisplacementVectorType(4*BeamType::NDOF);
	for( unsigned int n=0; n<2*BeamType::NDOF; n++ ){
		disp1_gc[n] = disp[n];
		disp2_gc[n] = disp[n+BeamType::NDOF];
	}
	// set the displacements to each Element
	b1.SetDisplacementInGlobalCoord(disp1_gc);
	b2.SetDisplacementInGlobalCoord(disp2_gc);
	// get the displacements in local coordinates
	disp1_lc = b1.GetDisplacementInLocalCoord();
	disp2_lc = b2.GetDisplacementInLocalCoord();

	// set all the local displacements into a single vector
	for( unsigned int n=0; n<2*BeamType::NDOF; n++ ){
		disp_lc[n] = disp1_lc[n];
		disp_lc[n+2*BeamType::NDOF] = disp2_lc[n];
	}
	test_disp = arma::abs(disp_lc  - expected_disp_lc )<1E-6;
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We expect to find the displacement in local coordinates.",
			(int)(4*BeamType::NDOF), // 2 beams and 2 points -> 4*NDOF
			static_cast<int>(sum(sum(test_disp,1)))
	);
	// find all the element forces in local coordinates
	ForceVectorType f1_lc = DisplacementVectorType(2*BeamType::NDOF),
									f2_lc = DisplacementVectorType(2*BeamType::NDOF),
									 f_lc = DisplacementVectorType(4*BeamType::NDOF);
	f1_lc = b1.GetForceInLocalCoord();
	f2_lc = b2.GetForceInLocalCoord();
	for( unsigned int n=0; n<2*BeamType::NDOF; n++ ){
		f_lc[n] = f1_lc[n];
		f_lc[n+2*BeamType::NDOF] = f2_lc[n];
	}
	arma::umat test_f = arma::abs(f_lc - f_elem_expected) < 1E-6;
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We expect to find the force elements in local coordinates.",
			(int)(4*BeamType::NDOF), // 2 beams and 2 points -> 4*NDOF
			static_cast<int>(sum(sum(test_f,1)))
	);
}

void
SolverTest::truss_triangle_tests(void){
}

void
SolverTest::beam_triangle_tests(void){
	/*
	 * Study case:
	 *
	 *     
	 *      
	 *      --> 12N
	 *     /|    |
	 *    / |    | 2m
	 *   /  |    |
	 *   ----    -
	 * ///  |
	 *
	 * |-----|
	 *   3.5m
	 *
	 * Numerical solutions have been generated by the Matlab code presented in 
	 * "A 3D Finite Element modeling composite wind tubine wings" by R. DE FRIA LOPE.
	 */   
	Point *p0 = PointManager::GetInstance().GetPoint(0.0,0.0,0.0),
	      *p1 = PointManager::GetInstance().GetPoint(3.5,0.0,0.0),
	      *p2 = PointManager::GetInstance().GetPoint(3.5,2.0,0.0);

	float cross_sec =  23, // in m^2
				alpha = 0.0,
				f2x=12;

	Material m = BASIC_C;

	int N = 3; // number of nodes/points
	arma::umat test;
	StiffnessMatrixType expected_K;

	ForceVectorType f_ext = ForceVectorType(N*BeamType::NDOF); // size = #nodes*NDOF
	f_ext(12) = f2x;

	// load the expected matrices
	bool check = expected_K.load(m_data_path + std::string("/Kg_Ctriangle_beams.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file Kg_Ctriangle_beams, may be you haven't run Matlab script",
			check,
			true
	);

	DisplacementVectorType expected_disp_gc, expected_disp_lc;
	check = expected_disp_gc.load(m_data_path + std::string("/disp_Ctriangle_beams.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file disp_Ctriangle_beams, may be you haven't run Matlab script",
			check,
			true
	);
	check = expected_disp_lc.load(m_data_path + std::string("/disp_lc_Ctriangle_beams.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file disp_Ctriangle_beams, may be you haven't run Matlab script",
			check,
			true
	);
	ForceVectorType f_reaction_sup_expected, f_elem_expected;
	check = f_reaction_sup_expected.load(m_data_path + std::string("/fsup_Ctriangle_beams.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file fsup_Ctriangle_beams, may be you haven't run Matlab script",
			check,
			true
	);
	check = f_elem_expected.load(m_data_path + std::string("/felem_Ctriangle_beams.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file felem_Ctriangle_beams, may be you haven't run Matlab script",
			check,
			true
	);


	// create the element objects
	BeamBarElement b0 = BeamBarElement(p0, p1, cross_sec, m, alpha);
	BeamBarElement b1 = BeamBarElement(p1, p2, cross_sec, m, alpha);
	BeamBarElement b2 = BeamBarElement(p2, p0, cross_sec, m, alpha);

	// create the stiffness matrix of the structure
	BeamStiffnessBuilder builder = BeamStiffnessBuilder(N);
	builder.Build(b0.GetStiffnessMatrix(), {0,1});
	builder.Build(b1.GetStiffnessMatrix(), {1,2});
	builder.Build(b2.GetStiffnessMatrix(), {2,0});
	
	// test the stiffness matrix values
	test = arma::abs(expected_K-builder.GetStiffnessMatrix())<1E-6;
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We expect to find the same stiffness matrix as the file.",
			(int)(N*6*N*6),
			static_cast<int>(sum(sum(test,1)))
	);

	// Boundary conditions
	BoundaryConditionsVectorType bc = BoundaryConditionsVectorType();
	// all supports are fixed supports -> all reactions are constraint
	// all happens in a single plan -> only 1 DOF is free -> TRIVIAL CASE
	for( unsigned int i=0; i<N; i++ ){
		if( i!=2){
			if( i!=1 ) bc.push_back({i,0}); // Vx is constraint only at 0
			bc.push_back({i,1}); // Vy is constraint at pt 0 and pt 1
		}
		bc.push_back({i,2}); // Vz is constraint at all points
		bc.push_back({i,3}); // Mx is constraint at all points
		bc.push_back({i,4}); // My is constraint at all points
		bc.push_back({i,5}); // Mz is constraint at all points
	}

	// initialize the data
	DisplacementVectorType disp = DisplacementVectorType(N*BeamType::NDOF); // size = #nodes
	ForceVectorType f_reaction_sup = ForceVectorType(N*BeamType::NDOF); // size = #nodes*NDOF
	ForceVectorType f_elem = ForceVectorType((N-1)*2*BeamType::NDOF); // size = #element*2*NDOF, 2: two nodes per elements)

	// ================
	// Solve the system
	// ================
	BeamSolverType  solver = BeamSolverType(builder.GetStiffnessMatrix(),&bc,&f_ext,&disp,&f_reaction_sup,&f_elem);
	// 1- find displacements of the nodes.
	solver.ComputeNodeDisplacements();
	//solver.ComputeNodeDisplacements(&disp,builder.GetStiffnessMatrix(),&f_ext,&bc);
	arma::umat test_disp = arma::abs(disp-expected_disp_gc)<1E-6;
	//std::cout << disp << std::endl;
	//std::cout << expected_disp_gc - disp << std::endl;
	//std::cout << "******" << std::endl;
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We expect to find the node displacements in GC.",
			(int)(N*6),
			static_cast<int>(sum(sum(test_disp,1)))
	);

	// 2- find the support's reactions
	solver.ComputeSupportReactions();
	arma::umat test_sup=arma::abs(f_reaction_sup-f_reaction_sup_expected)<1E-5;
	//std::cout << f_reaction_sup_expected << std::endl;
	//std::cout << f_reaction_sup - f_reaction_sup_expected << std::endl;
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We expect to find the same support reactions vector as the file.",
			(int)(N*6),
			static_cast<int>(sum(sum(test_sup,1)))
	);

	// 3- find the elements' internal forces and displacement in local coordinates
	// Parse all the Element and set the displacements in global coordinates
	// Then, build the f_elem vector getting back the displacements in local coordinates
	// as well as the internal forces in local coordinates
	DisplacementVectorType disp0_gc = DisplacementVectorType(2*BeamType::NDOF), // 1 beams and 2 nodes
												 disp1_gc = DisplacementVectorType(2*BeamType::NDOF),
												 disp2_gc = DisplacementVectorType(2*BeamType::NDOF),
												 disp0_lc = DisplacementVectorType(2*BeamType::NDOF),
												 disp1_lc = DisplacementVectorType(2*BeamType::NDOF),
												 disp2_lc = DisplacementVectorType(2*BeamType::NDOF),
												 disp_lc = DisplacementVectorType(3*2*BeamType::NDOF); // 3 beams and 2 nodes
	ForceVectorType f_elem_lc0 = ForceVectorType(2*BeamType::NDOF),
									f_elem_lc1 = ForceVectorType(2*BeamType::NDOF),
									f_elem_lc2 = ForceVectorType(2*BeamType::NDOF),
									f_elem_lc = ForceVectorType(3*2*BeamType::NDOF);

	for( unsigned int n=0; n<2*BeamType::NDOF; n++ ){
		disp0_gc[n] = disp[n];
		disp1_gc[n] = disp[n+BeamType::NDOF];
		disp2_gc[n] = disp[n+2*BeamType::NDOF];
	}
	// set the displacements to each Element
	b0.SetDisplacementInGlobalCoord(disp0_gc);
	b1.SetDisplacementInGlobalCoord(disp1_gc);
	b2.SetDisplacementInGlobalCoord(disp2_gc);
	// get the displacements in local coordinates
	disp0_lc = b0.GetDisplacementInLocalCoord();
	disp1_lc = b1.GetDisplacementInLocalCoord();
	disp2_lc = b2.GetDisplacementInLocalCoord();

	// get each force element in local coordinates
	f_elem_lc0 = b0.GetForceInLocalCoord();
	f_elem_lc1 = b1.GetForceInLocalCoord();
	f_elem_lc2 = b2.GetForceInLocalCoord();

	// set all the local displacements into a single vector
	for( unsigned int n=0; n<2*BeamType::NDOF; n++ ){
		disp_lc[n] = disp0_lc[n];
		disp_lc[n+2*BeamType::NDOF] = disp1_lc[n];
		disp_lc[n+4*BeamType::NDOF] = disp2_lc[n];

		f_elem_lc[n] = f_elem_lc0[n];
		f_elem_lc[n+2*BeamType::NDOF] = f_elem_lc1[n];
		f_elem_lc[n+4*BeamType::NDOF] = f_elem_lc2[n];
	}
	//std::cout << disp1_lc << std::endl;
	//std::cout << disp2_lc << std::endl;
	//std::cout << disp_lc << std::endl;
	//std::cout << expected_disp_lc << std::endl;
	//std::cout << disp_lc - expected_disp_lc << std::endl;
	test_disp = arma::abs(disp_lc  - expected_disp_lc )<1E-6;
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We expect to find the displacement in local coordinates.",
			(int)(6*BeamType::NDOF), // 2 beams and 2 points -> 4*NDOF
			static_cast<int>(sum(sum(test_disp,1)))
	);

	//std::cout << f_elem_lc << std::endl;
	//std::cout << f_elem_expected << std::endl;
	arma::umat test_f_lc = arma::abs(f_elem_expected - f_elem_lc)<1E-3; // strange ... epsilon has to be bigger
	//std::cout << test_f_lc << std::endl;
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We expect to find the element force in local coordinates.",
			(int)(6*BeamType::NDOF), // 2 beams and 2 points -> 4*NDOF
			static_cast<int>(sum(sum(test_f_lc,1)))
	);
}

void
SolverTest::truss_frame_tests(void){
}

void
SolverTest::beam_frame_tests(void){
	/*
	 *        | 10N
   *        |
   *        \/      _
   *        /\     |1.5 m
   *       /  \    |_
   *      |    |   | 2m
   *      |    |   |_
   *     ///  ///
   *      <-><->
   *      1m  1m
	 */
	Point *p0 = PointManager::GetInstance().GetPoint(0.0,0.0,0.0),
	      *p1 = PointManager::GetInstance().GetPoint(0.0,1.0,0.0),
	      *p2 = PointManager::GetInstance().GetPoint(0.0,2.0,0.0),
	      *p3 = PointManager::GetInstance().GetPoint(0.5,2.75,0.0),
	      *p4 = PointManager::GetInstance().GetPoint(1.0,3.5,0.0),
	      *p5 = PointManager::GetInstance().GetPoint(1.5,2.75,0.0),
	      *p6 = PointManager::GetInstance().GetPoint(2.0,2.0,0.0),
	      *p7 = PointManager::GetInstance().GetPoint(2.0,1.0,0.0),
	      *p8 = PointManager::GetInstance().GetPoint(2.0,0.0,0.0);

	float cross_sec =  23, // in m^2
				alpha = 0.0,
				f4y=-10;

	Material m = BASIC_C;

	int N = 9; // number of nodes/points
	arma::umat test;
	StiffnessMatrixType expected_K;

	ForceVectorType f_ext = ForceVectorType(N*BeamType::NDOF); // size = #nodes*NDOF
	f_ext(3*BeamType::NDOF+1) = f4y;

	// load the expected matrices
	bool check = expected_K.load(m_data_path + std::string("/Cframe_beams_Kg.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file Kg_Ctriangle_beams, may be you haven't run Matlab script",
			check,
			true
	);

	DisplacementVectorType expected_disp_gc, expected_disp_lc;
	check = expected_disp_gc.load(m_data_path + std::string("/Cframe_beams_disp.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file disp_Ctriangle_beams, may be you haven't run Matlab script",
			check,
			true
	);
	check = expected_disp_lc.load(m_data_path + std::string("/Cframe_beams_disp_lc.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file disp_Ctriangle_beams, may be you haven't run Matlab script",
			check,
			true
	);
	ForceVectorType f_reaction_sup_expected, f_elem_expected;
	check = f_reaction_sup_expected.load(m_data_path + std::string("/Cframe_beams_fsup.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file fsup_Ctriangle_beams, may be you haven't run Matlab script",
			check,
			true
	);
	check = f_elem_expected.load(m_data_path + std::string("/Cframe_beams_felem.mat"));
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We couldn't open the file felem_Ctriangle_beams, may be you haven't run Matlab script",
			check,
			true
	);

	// create the element objects
	// TODO: use a loop
	BeamBarElement b0 = BeamBarElement(p0, p1, cross_sec, m, alpha);
	BeamBarElement b1 = BeamBarElement(p1, p2, cross_sec, m, alpha);
	BeamBarElement b2 = BeamBarElement(p2, p3, cross_sec, m, alpha);
	BeamBarElement b3 = BeamBarElement(p3, p4, cross_sec, m, alpha);
	BeamBarElement b4 = BeamBarElement(p4, p5, cross_sec, m, alpha);
	BeamBarElement b5 = BeamBarElement(p5, p6, cross_sec, m, alpha);
	BeamBarElement b6 = BeamBarElement(p6, p7, cross_sec, m, alpha);
	BeamBarElement b7 = BeamBarElement(p7, p8, cross_sec, m, alpha);

	// create the stiffness matrix of the structure
	BeamStiffnessBuilder builder = BeamStiffnessBuilder(N);
	builder.Build(b0.GetStiffnessMatrix(), {0,1});
	builder.Build(b1.GetStiffnessMatrix(), {1,2});
	builder.Build(b2.GetStiffnessMatrix(), {2,3});
	builder.Build(b3.GetStiffnessMatrix(), {3,4});
	builder.Build(b4.GetStiffnessMatrix(), {4,5});
	builder.Build(b5.GetStiffnessMatrix(), {5,6});
	builder.Build(b6.GetStiffnessMatrix(), {6,7});
	builder.Build(b7.GetStiffnessMatrix(), {7,8});
	
	// test the stiffness matrix values
	//std::cout << arma::abs(expected_K-builder.GetStiffnessMatrix()) << std::endl;
	test = arma::abs(expected_K-builder.GetStiffnessMatrix())<1E-5; // !! Not 1E-6
	CPPUNIT_ASSERT_EQUAL_MESSAGE(
			"We expect to find the same stiffness matrix as the file.",
			(int)(N*6*N*6),
			static_cast<int>(sum(sum(test,1)))
	);

	// Boundary conditions
	BoundaryConditionsVectorType bc = BoundaryConditionsVectorType();
	// all supports are fixed supports -> all reactions are constraint
	// all happens in 2D -> u_z = 0 and theta_x and theta_y = 0
	for( unsigned int i=0; i<N; i++ ){
		if( i==0 || i==8 ){
			bc.push_back({i,0}); // Ux
			bc.push_back({i,1}); // Uy
			bc.push_back({i,5}); // Mz
		}
		bc.push_back({i,2}); // Vy is constraint at pt 0 and pt 1
		bc.push_back({i,3}); // Mx is constraint at all points
		bc.push_back({i,4}); // My is constraint at all points
	}

}
